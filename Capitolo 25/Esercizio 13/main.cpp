/* Capitolo 25 Esercizio 13
* Utilizzare TEA (§25.5.6) per comunicare “in modo sicuro” tra due computer. L'e-mail è minimamente accettabile. 
*/

/* 
* Provo ad utilizzare la libreria di rete di Boost (https://www.boost.org/) per creare una chat.
* Il programma parte e imposta la chiave;
* chiede se mettersi in ascolto o aprire una connessione;
* se ascolta chiede la Porta e apre il socket;
* se deve aprire una connessione chiede IP e Porta e tenta la connessione;
* stabilita la connessione con le password impostate inizia la comunicazione:
* i messaggi saranno cifrati prima dell'invio,
* i messaggi ricevuti saranno prima decifrati e poi visualizzati.
*/

/* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/

#include <iostream>
#include <sstream>
#include <iomanip>
// utilizzo delle librerie Boost
// client
#include "boost/asio.hpp"
// server
#include "boost/asio/ts/buffer.hpp"
#include "boost/asio/ts/internet.hpp"

// Funzione che cifra un tronchetto di dati
void encipher(const unsigned long* const v, unsigned long* const w, const unsigned long* const k) {
	// vettore v == testo da cifrare
	// vettore w == testo cifrato
	// vettore k == chiave

	// funziona prevedendo una dimensione di long pari a 4 byte
	static_assert(sizeof(long) == 4, "size of long wrong for TEA"); // TEA is Tiny Encrypt Algorithm

	unsigned long y = v[0]; // y contiene la prima parte del testo cifrato 1 long su 2
	unsigned long z = v[1]; // z contiene la seconda parte del testo cifrato 2° long

	unsigned long sum = 0;
	const unsigned long delta = 0x9E3779B9;

	for (unsigned long n = 32; n-- > 0;) {
		y += (z << 4 ^ z >> 5) + z ^ sum + k[sum & 3];
		sum += delta;
		z += (y << 4 ^ y >> 5) + y ^ sum + k[sum >> 11 & 3];
	}
	w[0] = y;
	w[1] = z;
}

// Funzione che decifra un tronchetto di dati
void decipher(const unsigned long* const v, unsigned long* const w, const unsigned long* const k) {
	// vettore v == testo da decifrare
	// vettore w == testo decifrato
	// vettore k == chiave

	// funziona prevedendo una dimensione di long pari a 4 byte
	static_assert(sizeof(long) == 4, "size of long wrong for TEA"); // TEA is Tiny Encrypt Algorithm

	unsigned long y = v[0]; // y contiene la prima parte del testo cifrato 1 long su 2
	unsigned long z = v[1]; // z contiene la seconda parte del testo cifrato 2° long

	unsigned long sum = 0xC6EF3720;
	const unsigned long delta = 0x9E3779B9;

	// sum = delta<<5, in general sum = delta * n
	for (unsigned long n = 32; n-- > 0;) {
		z -= (y << 4 ^ y >> 5) + y ^ sum + k[sum >> 11 & 3];
		sum -= delta;
		y -= (z << 4 ^ z >> 5) + z ^ sum + k[sum & 3];
	}
	w[0] = y;
	w[1] = z;
}

// Creazione della connessione in uscita - Eliminata
/*
boost::asio::ip::tcp::socket* connetti(const std::string& hostname, const std::string& porta) {
	using boost::asio::ip::tcp;
	
	boost::asio::io_context context{};
	tcp::socket* s = new tcp::socket(context);
	tcp::resolver r(context);
	boost::asio::connect(*s, r.resolve(hostname, porta));
	
	return s;
}
*/

// sarebbe più elegante creare un oggetto dove dove impostare i parametri e funzioni membro per cifrare e decifrare.
std::string cifra_decifra(const std::string& msg, std::string& key, const bool cifra_decifra = 1) {
	// di default cifro msg in una stringa utilizzando key altrimenti decifro quando cifra_decifra=0
	std::string messaggio_elaborato;
	// dimensione chunk per la cifratura e dimensione della chiave di cifratura
	const int nchar = 2 * sizeof(long); // 64 bit
	const int kchar = 2 * nchar; // 128 bit

	while (key.size() < kchar) key += '0'; // pad key: riempe la lunghezza della chiave quando più corta di 128 bit

	// puntatore alla chiave - k per key
	const unsigned long* k = reinterpret_cast<const unsigned long*>(key.data());
	// buffer dei dati in uscita dalle funzioni di cifratura e decifratura e il puntatore al buffer
	char outbuf[nchar + 1];
	outbuf[nchar] = 0; // terminatore nell'array di caratteri
	unsigned long* outptr = reinterpret_cast<unsigned long*>(outbuf);
	// buffer dei dati in ingresso alle funzioni di cifratura e decifratura e il puntatore al buffer
	char inbuf[nchar + 1];
	inbuf[nchar] = 0;
	unsigned long* inptr = reinterpret_cast<unsigned long*>(inbuf);
	
	for (size_t l = 0; l < msg.size(); l += nchar) {
		// sono rimasti abbastanca caratteri da riempire il buffer?
		size_t nchar_rimasti = ((l + nchar) >= msg.size() ? (msg.size() - l) : nchar);

		// riempimento buffer con un tronchetto o con quello che rimane
		for (size_t i = 0; i < nchar_rimasti; ++i) {
			inbuf[i] = msg[(l + i)];
		}

		// per riempire il buffer in un intero tronchetto da cifrare
		for (size_t i = nchar_rimasti; i < nchar; ++i) inbuf[i] = '\0';

		// cifra o decifra il messaggio
		if (cifra_decifra) encipher(inptr, outptr, k);
		else decipher(inptr, outptr, k);

		// aggiungiamo if per controllare che la stringa non abbia il carattere terminatore ma sia della lunghezza dei soli caratteri utili e non di tutto il buffer.
		for (size_t i = 0; i < nchar; ++i) if (outbuf[i] != '\0') messaggio_elaborato += outbuf[i];
	}

	return messaggio_elaborato;
}

int main() {
	// dimensione chunk per la cifratura e dimensione della chiave di cifratura
	const int nchar = 2 * sizeof(long); // 64 bit
	//const int kchar = 2 * nchar; // 128 bit
	
	// chiave di cifratura
	std::string key;
	// avvio come client o server
	bool client{ false };

	// Recuperiamo la chiave per cifrare e decifrare i messaggi
	std::cout << "Chiave crittografica? " << std::endl;
	std::cin >> key;

	// decidiamo se siamo Server o Client
	char risposta = ' ';
	std::cout << "\nScegli 1 per Collegarsi o 2 per attendere una Connessione: ";
	// svuoto lo standard input da caratteri bianchi
	std::cin >> std::ws;

	while (std::cin >> risposta) {
		if (risposta == '1') {
			client = true;
			break;
		}
		if (risposta == '2') {
			client = false;
			break;
		}
		risposta = ' ';
		std::cout << "\nPuoi scegliere solo 1 per Collegarti o 2 per Attendere una Connessione: ";
	}

	try {
		// collegamento
		// ho eliminato la mia connetti perché dovrei creare un oggetto che contenga anche il context, uscito dalla funzione questo viene distrutto nel socket creato invalidandolo
		//boost::asio::ip::tcp::socket* s = connetti(hostname, porta);
		using boost::asio::ip::tcp;
		boost::asio::io_context context{};
		tcp::socket sock(context);
		tcp::resolver r(context);
		// messaggio contiene il testo da inviare, risposta il messaggio in chiaro ricevuto e messaggio_cifrato i dati cifrati ricevuti
		std::string messaggio, messaggio_cifrato, risposta;

		if (client) {
			// Siamo noi a collegarci, ci serve un hostname e una porta
			std::string hostname;
			std::string porta;
			std::cout << "\n\nHostname o indirizzo IP a cui collegarsi: ";
			std::cin >> hostname;
			std::cout << "\nPorta di comunicazione: ";
			std::cin >> porta;
			boost::asio::connect(sock, r.resolve(hostname, porta));
			risposta = "#Passo";
			messaggio = "";
			messaggio_cifrato = "";
		}
		else {
			// Attendiamo una connessione su una porta tcp
			std::string porta;
			std::cout << "\nPorta di comunicazione: ";
			std::cin >> porta;
			// Un acceptor che aspetta il client
			boost::asio::ip::tcp::acceptor acpt(context, tcp::endpoint(tcp::v4(), std::atoi(porta.c_str())));
			std::cout << "Attendo una connessione sulla porta " << porta << ".\n";
			acpt.accept(sock);
			// connessione accettata, inizio il loop
			risposta = "";
			messaggio = "#Passo"; // attendiamo messaggi dal client
			messaggio_cifrato = "";
		}

		// Inizio loop, messaggio è la stringa da inviare mentre risposta (in questo scope, contiene il messaggio ricevuto)
		char ricbuf[(nchar + 1)]; // utilizzare inbuf
		ricbuf[nchar] = 0;
		size_t ricbytes{ 0 };
		boost::system::error_code error;
		std::cout << "\nScrivi #Esci ripettando anche le maiuscole per terminare il programma\n\n\n";
		
	while (messaggio != "#Esci") {
			
			// Invia messaggi finché non passiamo la parola e dobbiamo attendere la risposta
			while (risposta == "#Passo") {
				// Scrivi il messaggio
				std::cout << "Scrivi il messaggio da inviare (#Passo per passare alla ricezione):\n";
				std::cin >> std::ws;
				std::getline(std::cin, messaggio, '\n');
				// cifra il messaggio
				messaggio_cifrato = cifra_decifra(messaggio, key, 1);
				// invia il messaggio cifrato al buffer di rete
				boost::asio::write(sock, boost::asio::buffer(messaggio_cifrato.c_str(), (messaggio_cifrato.size() + 0)), error);
				// Se passiamo la parola (controllato da messaggio) allora non lo è più risposta
				if (messaggio == "#Passo") risposta = "";
				if (messaggio == "#Esci") risposta = "#Esci";
			}

			messaggio_cifrato = "";
			
			// ci sono dati nel buffer di ricezione?
			ricbytes = sock.available();

			// Riceviamo dati finché non ci passano la parola
			while (ricbytes && messaggio == "#Passo") {
				ricbytes = boost::asio::read(sock, boost::asio::buffer(ricbuf, nchar), error);
				
				// riversiamo i bytes cifrati ricevuti nella stringa messaggio_cifrato
				for (size_t i = 0; i < ricbytes; ++i) {
					messaggio_cifrato += ricbuf[i];
				}

				if (error == boost::asio::stream_errc::eof) break;
				if (error) throw std::system_error(error);
			
				// ci sono altri dati? aggiorniamo, se sarà 0 allora usciamo dal loop per decifrare l'intero messaggio
				ricbytes = sock.available();
			}

			// decifra se ci sono dati
			if (messaggio_cifrato.size()) risposta = cifra_decifra(messaggio_cifrato, key, 0);

			// stampa la risposta se ci sono dati
			if (risposta.size()) std::cout << "Ristposta: " << risposta << std::endl;

			// Usciamo o ricominciato da capo?
			if (risposta == "#Esci") messaggio = risposta; else if (risposta != "#Passo") risposta = "";
		} // fine loop client o server
	} // fine try
	catch (std::exception& e) {
		std::cerr << "\n\n\nEccezione non gestita: " << e.what() << "\n\n\n";
		return 1;
	}
	catch (...) {
		std::cerr << "\n\n\nQualcosa è andato storto, prendetevela con CiroInGiro!\n\n\n";
		return 99;
	}

	return 0;
}